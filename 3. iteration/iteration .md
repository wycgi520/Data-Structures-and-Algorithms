# 1. 递归

## 1.1 祖母的手提箱中,包括若干嵌套盒子和要找的钥匙
1. 循环的方法
	- 创建一个盒子堆用来放置盒子,从盒子堆里取出盒子进行拆解,寻找钥匙, 如果不是钥匙而是盒子, 便又放到盒子堆里
2. 递归的方法
	- 仔细检查手提箱中每一样东西,如果是盒子, 就继续进去里面检查, 直到发现钥匙

## 1.2 基线条件和递归条件

- 基线条件是指函数不再调用自己, 避免无限循环
- 递归条件是指函数再次调用自己

## 1.3 栈
    def greet(name):
    	print("hello, " + name + "!")
    	greet2(name)
    	print("getting ready to say bye...")
    	bye()
    def greet2(name):
    	print("how are you, " + name + "?")
    def bye():
    	print("ok bye!")
1. 先调用greet("maggie") , 计算机为该函数调用分配一块内存,该内存中name被设置为maggie
2. 接下来打印hello, maggie, 再调用greet2("maggie"), 计算机同样为该函数调用分配一块内存
(**计算机用栈来表示这些内存块,其中第二个内存块位于第一个内存块上面**)
3. 接着, 打印how are you, maggie? 然后从函数调用返回, 此时, 栈顶的内存块被弹出, 现在, 栈顶的内存块是函数greet, 也即返回到了函数greet(**当调用另一个函数时, 当前函数暂停并处于未完成状态,该函数的所有变量的值都还在内存中,执行完greet2后返回greet**)
4. 打印getting ready to say bye...
5. 调用函数bye, 在栈顶添加函数bye的内存块, 然后打印ok bye!, 并从这个函数返回, 函数bye从栈顶弹出
6. 又回到了函数greet,栈顶的内存块又是函数greet , 由于函数greet接下来已经结束了, 就从函数greet 返回, 函数greet从栈顶弹出

### 1.3.1 分析factorial
    def fact(x):
    	if x == 1:
    		return 1
    	else:
    		return x * fact(x-1)
对于fact(3):
1. 调用fact(3), 分配一个内存块, 变量x为3,并添加到栈顶
2. 满足递归条件(x!=1),调用3*fact(2), 给fact(2)分配一个内存块, 变量x为2, 并添加到栈顶
3. 满足递归条件(x!=1),调用2*fact(1),给fact(1)分配一个内存块, 变量x为1,并添加到栈顶
4. 满足基线条件(x==1),返回1, fact(1)从栈顶弹出
5. fact(2)返回2*1, fact(2)从栈顶弹出
6. fact(3)返回3×2×1, fact(3)从栈顶弹出

## 1.4 总结
- 递归指的是调用自己的函数
- 栈有两种操作: 压入和弹出
- 所有函数调用都进入调用栈
- 调用栈可能很长, 占用大量的内存